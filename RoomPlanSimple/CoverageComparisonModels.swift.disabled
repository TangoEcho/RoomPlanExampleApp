import Foundation
import UIKit
import simd

// MARK: - Coverage Scenario Data Models

/// Represents a WiFi coverage scenario (current or improved)
struct CoverageScenario {
    let id: UUID
    let name: String
    let description: String
    let createdAt: Date
    
    // Performance metrics
    let coveragePercentage: Float // 0-100
    let averageSpeed: Float // Mbps
    let reliabilityScore: Float // 0-1
    let confidenceScore: Float // 0-1
    
    // Coverage analysis
    let roomCoverage: [RoomCoverageDetail]
    let deadZones: [DeadZone]
    let strongSignalAreas: [StrongSignalArea]
    
    // Device configuration
    let networkDevices: [NetworkDeviceConfiguration]
    let recommendations: [CustomerRecommendation]?
    
    // Visual data
    let coverageMap: CoverageMapData?
    let heatmapData: WiFiHeatmapData?
    
    init(name: String, description: String = "", 
         coveragePercentage: Float, averageSpeed: Float, reliabilityScore: Float, confidenceScore: Float,
         roomCoverage: [RoomCoverageDetail] = [], deadZones: [DeadZone] = [], strongSignalAreas: [StrongSignalArea] = [],
         networkDevices: [NetworkDeviceConfiguration] = [], recommendations: [CustomerRecommendation]? = nil,
         coverageMap: CoverageMapData? = nil, heatmapData: WiFiHeatmapData? = nil) {
        
        self.id = UUID()
        self.name = name
        self.description = description
        self.createdAt = Date()
        self.coveragePercentage = coveragePercentage
        self.averageSpeed = averageSpeed
        self.reliabilityScore = reliabilityScore
        self.confidenceScore = confidenceScore
        self.roomCoverage = roomCoverage
        self.deadZones = deadZones
        self.strongSignalAreas = strongSignalAreas
        self.networkDevices = networkDevices
        self.recommendations = recommendations
        self.coverageMap = coverageMap
        self.heatmapData = heatmapData
    }
}

struct RoomCoverageDetail {
    let roomType: RoomType
    let roomName: String
    let coverageLevel: CoverageLevel
    let averageSignal: Float // dBm
    let averageSpeed: Float // Mbps
    let problemAreas: [String] // Descriptions of issues
    let improvements: [String] // Descriptions of improvements
}

struct DeadZone {
    let area: CGRect
    let roomType: RoomType
    let severity: DeadZoneSeverity
    let description: String
    let suggestedSolution: String
}

enum DeadZoneSeverity {
    case mild // -85 to -80 dBm
    case moderate // -90 to -85 dBm  
    case severe // < -90 dBm
    
    var displayName: String {
        switch self {
        case .mild: return "Weak Signal"
        case .moderate: return "Poor Signal"
        case .severe: return "No Signal"
        }
    }
    
    var color: UIColor {
        switch self {
        case .mild: return .systemYellow
        case .moderate: return .systemOrange
        case .severe: return .systemRed
        }
    }
}

struct StrongSignalArea {
    let area: CGRect
    let roomType: RoomType
    let averageSignal: Float
    let averageSpeed: Float
    let description: String
}

struct NetworkDeviceConfiguration {
    let deviceType: NetworkDeviceManager.NetworkDevice.DeviceType
    let position: simd_float3
    let model: String
    let capabilities: [String] // WiFi 7, WiFi 6E, etc.
    let estimatedCost: String?
    let installationComplexity: InstallationComplexity
}

enum InstallationComplexity {
    case simple // Plug and play
    case moderate // Some configuration needed
    case complex // Professional installation recommended
    
    var displayName: String {
        switch self {
        case .simple: return "Easy Setup"
        case .moderate: return "Moderate Setup"
        case .complex: return "Professional Install"
        }
    }
    
    var timeEstimate: String {
        switch self {
        case .simple: return "15 minutes"
        case .moderate: return "1 hour"
        case .complex: return "2-3 hours"
        }
    }
}

struct CoverageMapData {
    let gridSize: CGSize
    let resolution: Float // meters per grid point
    let signalLevels: [[Float]] // 2D array of signal strengths
    let coverageZones: [CoverageZone]
}

struct CoverageZone {
    let bounds: CGRect
    let level: CoverageLevel
    let averageSignal: Float
    let deviceCount: Int // Number of devices that can reliably connect
}

// MARK: - Customer Benefits and Recommendations

struct CustomerBenefit {
    let icon: String
    let title: String
    let description: String
    let quantifiedImprovement: String? // e.g., "50% faster", "3x more coverage"
    let priority: BenefitPriority
}

enum BenefitPriority {
    case high
    case medium
    case low
    
    var sortOrder: Int {
        switch self {
        case .high: return 0
        case .medium: return 1
        case .low: return 2
        }
    }
}

struct CustomerRecommendation {
    let title: String
    let description: String
    let estimatedCost: String
    let timeframe: String // e.g., "Same day", "1-2 days"
    let priority: RecommendationPriority
    let benefits: [String]
    let requirements: [String]? // Any prerequisites
}

enum RecommendationPriority {
    case essential // Must have for basic functionality
    case recommended // Significant improvement
    case optional // Nice to have
    
    var displayName: String {
        switch self {
        case .essential: return "Essential"
        case .recommended: return "Recommended"
        case .optional: return "Optional"
        }
    }
    
    var color: UIColor {
        switch self {
        case .essential: return SpectrumBranding.Colors.error
        case .recommended: return SpectrumBranding.Colors.accent
        case .optional: return SpectrumBranding.Colors.secondary
        }
    }
}

// MARK: - Improvement Calculations

struct CoverageImprovementCalculator {
    
    static func calculate(current: CoverageScenario, improved: CoverageScenario) -> CoverageImprovementResult {
        let coverageImprovement = improved.coveragePercentage - current.coveragePercentage
        let speedImprovementPercent = ((improved.averageSpeed - current.averageSpeed) / current.averageSpeed) * 100
        let reliabilityImprovementPercent = ((improved.reliabilityScore - current.reliabilityScore) / current.reliabilityScore) * 100
        
        let roomImprovements = calculateRoomImprovements(current: current, improved: improved)
        let deadZoneReduction = current.deadZones.count - improved.deadZones.count
        let newStrongAreas = improved.strongSignalAreas.count - current.strongSignalAreas.count
        
        return CoverageImprovementResult(
            coverageImprovement: coverageImprovement,
            speedImprovement: speedImprovementPercent,
            reliabilityImprovement: reliabilityImprovementPercent,
            roomImprovements: roomImprovements,
            deadZoneReduction: deadZoneReduction,
            newStrongAreas: newStrongAreas,
            overallScore: calculateOverallImprovementScore(
                coverage: coverageImprovement,
                speed: speedImprovementPercent,
                reliability: reliabilityImprovementPercent
            )
        )
    }
    
    private static func calculateRoomImprovements(current: CoverageScenario, improved: CoverageScenario) -> [RoomImprovementDetail] {
        var improvements: [RoomImprovementDetail] = []
        
        for improvedRoom in improved.roomCoverage {
            if let currentRoom = current.roomCoverage.first(where: { $0.roomType == improvedRoom.roomType }) {
                let signalImprovement = improvedRoom.averageSignal - currentRoom.averageSignal
                let speedImprovement = improvedRoom.averageSpeed - currentRoom.averageSpeed
                let levelImprovement = improvedRoom.coverageLevel != currentRoom.coverageLevel
                
                if signalImprovement > 0 || speedImprovement > 0 || levelImprovement {
                    improvements.append(RoomImprovementDetail(
                        roomType: improvedRoom.roomType,
                        roomName: improvedRoom.roomName,
                        signalImprovement: signalImprovement,
                        speedImprovement: speedImprovement,
                        coverageLevelChange: levelImprovement ? (currentRoom.coverageLevel, improvedRoom.coverageLevel) : nil
                    ))
                }
            }
        }
        
        return improvements
    }
    
    private static func calculateOverallImprovementScore(coverage: Float, speed: Float, reliability: Float) -> Float {
        // Weighted average of improvements
        let coverageWeight: Float = 0.4
        let speedWeight: Float = 0.4
        let reliabilityWeight: Float = 0.2
        
        let normalizedCoverage = min(100, max(0, coverage)) / 100
        let normalizedSpeed = min(200, max(0, speed)) / 200 // Cap at 200% improvement
        let normalizedReliability = min(100, max(0, reliability)) / 100
        
        return (normalizedCoverage * coverageWeight + 
                normalizedSpeed * speedWeight + 
                normalizedReliability * reliabilityWeight) * 100
    }
}

struct CoverageImprovementResult {
    let coverageImprovement: Float // Percentage points
    let speedImprovement: Float // Percent increase
    let reliabilityImprovement: Float // Percent increase
    let roomImprovements: [RoomImprovementDetail]
    let deadZoneReduction: Int // Number of dead zones eliminated
    let newStrongAreas: Int // Number of new strong signal areas
    let overallScore: Float // 0-100 overall improvement score
}

struct RoomImprovementDetail {
    let roomType: RoomType
    let roomName: String
    let signalImprovement: Float // dB improvement
    let speedImprovement: Float // Mbps improvement
    let coverageLevelChange: (from: CoverageLevel, to: CoverageLevel)?
}

// MARK: - Customer Benefits Generator

struct CustomerBenefitsGenerator {
    
    static func generateBenefits(current: CoverageScenario, improved: CoverageScenario) -> [CustomerBenefit] {
        var benefits: [CustomerBenefit] = []
        let improvements = CoverageImprovementCalculator.calculate(current: current, improved: improved)
        
        // Coverage benefits
        if improvements.coverageImprovement > 10 {
            benefits.append(CustomerBenefit(
                icon: "ðŸ“¶",
                title: "Expanded WiFi Coverage",
                description: "Get reliable internet in every room of your home with \(Int(improvements.coverageImprovement))% more coverage area.",
                quantifiedImprovement: "+\(Int(improvements.coverageImprovement))% coverage",
                priority: .high
            ))
        }
        
        // Speed benefits
        if improvements.speedImprovement > 20 {
            benefits.append(CustomerBenefit(
                icon: "âš¡",
                title: "Faster Internet Speeds",
                description: "Stream 4K videos, game online, and video chat without buffering with \(Int(improvements.speedImprovement))% faster speeds.",
                quantifiedImprovement: "+\(Int(improvements.speedImprovement))% speed",
                priority: .high
            ))
        }
        
        // Reliability benefits
        if improvements.reliabilityImprovement > 15 {
            benefits.append(CustomerBenefit(
                icon: "ðŸ›¡ï¸",
                title: "Rock-Solid Reliability",
                description: "Say goodbye to dropped connections and unstable internet with \(Int(improvements.reliabilityImprovement))% better reliability.",
                quantifiedImprovement: "+\(Int(improvements.reliabilityImprovement))% reliability",
                priority: .high
            ))
        }
        
        // Dead zone elimination
        if improvements.deadZoneReduction > 0 {
            benefits.append(CustomerBenefit(
                icon: "ðŸŽ¯",
                title: "Eliminate Dead Zones",
                description: "Remove \(improvements.deadZoneReduction) dead zone\(improvements.deadZoneReduction > 1 ? "s" : "") where you previously had no internet access.",
                quantifiedImprovement: "\(improvements.deadZoneReduction) dead zone\(improvements.deadZoneReduction > 1 ? "s" : "") eliminated",
                priority: .high
            ))
        }
        
        // Multi-device support
        if improved.networkDevices.count > current.networkDevices.count {
            let newDevices = improved.networkDevices.count - current.networkDevices.count
            benefits.append(CustomerBenefit(
                icon: "ðŸ“±",
                title: "Support More Devices",
                description: "Connect all your smart home devices, phones, tablets, and computers without slowdowns.",
                quantifiedImprovement: "+\(newDevices) device\(newDevices > 1 ? "s" : "")",
                priority: .medium
            ))
        }
        
        // Future-proofing
        if improved.networkDevices.contains(where: { $0.capabilities.contains("WiFi 7") }) {
            benefits.append(CustomerBenefit(
                icon: "ðŸš€",
                title: "Future-Proof Technology",
                description: "Get the latest WiFi 7 technology that's ready for tomorrow's internet demands and smart devices.",
                quantifiedImprovement: "Latest WiFi 7",
                priority: .medium
            ))
        }
        
        // Cost savings (estimated)
        benefits.append(CustomerBenefit(
            icon: "ðŸ’°",
            title: "Maximize Your Internet Investment",
            description: "Get the full value from your internet plan with optimized coverage that delivers the speeds you're paying for.",
            quantifiedImprovement: "Full plan utilization",
            priority: .medium
        ))
        
        // Work from home benefits
        if improvements.roomImprovements.contains(where: { $0.roomType == .office }) {
            benefits.append(CustomerBenefit(
                icon: "ðŸ’¼",
                title: "Better Work From Home",
                description: "Improve productivity with reliable video calls, file uploads, and cloud access from your home office.",
                quantifiedImprovement: nil,
                priority: .medium
            ))
        }
        
        return benefits.sorted { $0.priority.sortOrder < $1.priority.sortOrder }
    }
}

// MARK: - Supporting Types

// CoverageLevel enum is defined in NetworkDeviceManager.swift