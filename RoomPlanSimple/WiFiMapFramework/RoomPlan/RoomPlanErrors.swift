import Foundation
#if canImport(RoomPlan) && os(iOS)

/// Errors that can occur during RoomPlan parsing and processing
public enum RoomPlanParsingError: LocalizedError, Equatable {
    case invalidUSDZFile
    case missingGeometryData
    case coordinateSystemMismatch
    case insufficientRoomData
    case corruptedMeshData
    case unsupportedFileFormat
    case fileAccessDenied
    case memoryLimitExceeded
    case processingTimeout
    case invalidDimensions
    case noViableSurfaces
    
    public var errorDescription: String? {
        switch self {
        case .invalidUSDZFile:
            return "Invalid or corrupted USDZ file"
        case .missingGeometryData:
            return "Required geometry data missing from scan"
        case .coordinateSystemMismatch:
            return "Coordinate system inconsistency detected"
        case .insufficientRoomData:
            return "Insufficient room data for analysis"
        case .corruptedMeshData:
            return "Mesh data appears corrupted or unreadable"
        case .unsupportedFileFormat:
            return "Unsupported file format - USDZ required"
        case .fileAccessDenied:
            return "Access denied to scan file"
        case .memoryLimitExceeded:
            return "Memory limit exceeded during processing"
        case .processingTimeout:
            return "Processing timeout - scan too complex"
        case .invalidDimensions:
            return "Invalid or unrealistic room dimensions detected"
        case .noViableSurfaces:
            return "No viable placement surfaces found"
        }
    }
    
    public var failureReason: String? {
        switch self {
        case .invalidUSDZFile:
            return "The USDZ file may be corrupted, incomplete, or not generated by RoomPlan"
        case .missingGeometryData:
            return "The scan does not contain sufficient 3D geometry information"
        case .coordinateSystemMismatch:
            return "The coordinate system used in the scan cannot be interpreted correctly"
        case .insufficientRoomData:
            return "The room scan is incomplete or missing critical structural elements"
        case .corruptedMeshData:
            return "The 3D mesh data contains errors or inconsistencies"
        case .unsupportedFileFormat:
            return "Only USDZ files generated by Apple RoomPlan are supported"
        case .fileAccessDenied:
            return "The application does not have permission to read the scan file"
        case .memoryLimitExceeded:
            return "The scan is too large or complex to process with available memory"
        case .processingTimeout:
            return "The scan processing took longer than the allowed time limit"
        case .invalidDimensions:
            return "The detected room dimensions are outside realistic bounds"
        case .noViableSurfaces:
            return "No furniture surfaces suitable for WiFi equipment placement were found"
        }
    }
    
    public var recoverySuggestion: String? {
        switch self {
        case .invalidUSDZFile:
            return "Try rescanning the room with RoomPlan, ensuring complete coverage"
        case .missingGeometryData:
            return "Rescan the room ensuring all areas are properly captured"
        case .coordinateSystemMismatch:
            return "Check that the scan was created with a compatible version of RoomPlan"
        case .insufficientRoomData:
            return "Rescan the room with more thorough coverage of walls and furniture"
        case .corruptedMeshData:
            return "Try rescanning the room or using a different scan file"
        case .unsupportedFileFormat:
            return "Ensure you are using a USDZ file generated by Apple RoomPlan"
        case .fileAccessDenied:
            return "Check file permissions and ensure the app has access to the scan file"
        case .memoryLimitExceeded:
            return "Try processing a smaller room or restart the app to free memory"
        case .processingTimeout:
            return "Try simplifying the scan or breaking large rooms into smaller sections"
        case .invalidDimensions:
            return "Verify the room was scanned correctly and dimensions are realistic"
        case .noViableSurfaces:
            return "Ensure the room contains furniture suitable for equipment placement"
        }
    }
    
    /// Indicates whether this error is recoverable through user action
    public var isRecoverable: Bool {
        switch self {
        case .invalidUSDZFile, .missingGeometryData, .insufficientRoomData, .invalidDimensions, .noViableSurfaces:
            return true // User can rescan
        case .corruptedMeshData, .unsupportedFileFormat:
            return true // User can try different file
        case .fileAccessDenied:
            return true // User can fix permissions
        case .coordinateSystemMismatch:
            return false // System incompatibility
        case .memoryLimitExceeded, .processingTimeout:
            return true // User can try smaller scans or restart
        }
    }
    
    /// The severity level of this error
    public var severity: ErrorSeverity {
        switch self {
        case .invalidUSDZFile, .missingGeometryData, .insufficientRoomData:
            return .medium // Common user errors
        case .corruptedMeshData, .coordinateSystemMismatch:
            return .high // Data integrity issues
        case .unsupportedFileFormat, .fileAccessDenied:
            return .low // Simple configuration issues
        case .memoryLimitExceeded, .processingTimeout:
            return .high // System resource issues
        case .invalidDimensions, .noViableSurfaces:
            return .medium // Analysis limitations
        }
    }
}

/// Error severity levels
public enum ErrorSeverity {
    case low    // Minor issues, easy to resolve
    case medium // Moderate issues, may require user action
    case high   // Serious issues, may prevent operation
    
    public var description: String {
        switch self {
        case .low: return "Low"
        case .medium: return "Medium"
        case .high: return "High"
        }
    }
}

/// Warnings that can occur during RoomPlan processing
public enum RoomPlanWarning: LocalizedError {
    case lowScanQuality(Double)
    case missingFurniture
    case incompleteWallDetection
    case scalingApplied(Double)
    case coordinateTransformationApplied
    case inferredGeometry([String])
    case lowConfidenceFurniture([String])
    case potentialObstacleIssues([String])
    
    public var errorDescription: String? {
        switch self {
        case .lowScanQuality(let quality):
            return "Scan quality is below optimal (quality: \(String(format: "%.1f", quality * 100))%)"
        case .missingFurniture:
            return "No furniture detected in room scan"
        case .incompleteWallDetection:
            return "Some walls may not have been detected correctly"
        case .scalingApplied(let factor):
            return "Automatic scaling applied (factor: \(String(format: "%.3f", factor)))"
        case .coordinateTransformationApplied:
            return "Coordinate system transformation was applied"
        case .inferredGeometry(let elements):
            return "Some geometry was inferred: \(elements.joined(separator: ", "))"
        case .lowConfidenceFurniture(let items):
            return "Low confidence furniture detection: \(items.joined(separator: ", "))"
        case .potentialObstacleIssues(let issues):
            return "Potential RF analysis issues: \(issues.joined(separator: ", "))"
        }
    }
    
    public var recoverySuggestion: String? {
        switch self {
        case .lowScanQuality:
            return "Consider rescanning for better accuracy"
        case .missingFurniture:
            return "Verify furniture is present and visible during scanning"
        case .incompleteWallDetection:
            return "Ensure all walls are properly scanned"
        case .scalingApplied:
            return "Verify room dimensions are correct"
        case .coordinateTransformationApplied:
            return "Check that coordinate system matches expectations"
        case .inferredGeometry:
            return "Verify inferred elements are correct"
        case .lowConfidenceFurniture:
            return "Manually verify furniture detection results"
        case .potentialObstacleIssues:
            return "Review RF analysis results carefully"
        }
    }
}

/// Results wrapper that includes both data and any warnings
public struct RoomPlanResult<T> {
    public let data: T
    public let warnings: [RoomPlanWarning]
    public let processingTime: TimeInterval
    public let qualityMetrics: ProcessingQualityMetrics?
    
    public init(
        data: T,
        warnings: [RoomPlanWarning] = [],
        processingTime: TimeInterval = 0,
        qualityMetrics: ProcessingQualityMetrics? = nil
    ) {
        self.data = data
        self.warnings = warnings
        self.processingTime = processingTime
        self.qualityMetrics = qualityMetrics
    }
    
    /// Whether the result has any warnings
    public var hasWarnings: Bool {
        return !warnings.isEmpty
    }
    
    /// Whether the result is considered high quality
    public var isHighQuality: Bool {
        guard let metrics = qualityMetrics else { return true }
        return metrics.overallQuality > 0.8 && warnings.count <= 2
    }
}

/// Metrics about the processing quality
public struct ProcessingQualityMetrics {
    public let overallQuality: Double
    public let geometryAccuracy: Double
    public let furnitureDetectionRate: Double
    public let surfaceExtractionRate: Double
    public let memoryUsage: Int // bytes
    
    public init(
        overallQuality: Double,
        geometryAccuracy: Double,
        furnitureDetectionRate: Double,
        surfaceExtractionRate: Double,
        memoryUsage: Int
    ) {
        self.overallQuality = overallQuality
        self.geometryAccuracy = geometryAccuracy
        self.furnitureDetectionRate = furnitureDetectionRate
        self.surfaceExtractionRate = surfaceExtractionRate
        self.memoryUsage = memoryUsage
    }
}

/// Error handling utilities
public class RoomPlanErrorHandler {
    
    /// Convert system errors to RoomPlan-specific errors
    /// - Parameter systemError: The original system error
    /// - Returns: Corresponding RoomPlan error
    public static func mapSystemError(_ systemError: Error) -> RoomPlanParsingError {
        if let nsError = systemError as NSError? {
            switch nsError.code {
            case NSFileReadNoSuchFileError:
                return .invalidUSDZFile
            case NSFileReadNoPermissionError:
                return .fileAccessDenied
            case NSFileReadCorruptFileError:
                return .corruptedMeshData
            default:
                // Check for memory errors
                if nsError.domain.contains("memory") || nsError.domain.contains("malloc") {
                    return .memoryLimitExceeded
                }
                return .invalidUSDZFile
            }
        }
        
        // Check for timeout errors
        if systemError.localizedDescription.lowercased().contains("timeout") {
            return .processingTimeout
        }
        
        return .invalidUSDZFile
    }
    
    /// Validate room model for common issues
    /// - Parameter roomModel: The room model to validate
    /// - Throws: RoomPlanParsingError if critical issues found
    public static func validateRoomModel(_ roomModel: RoomModel) throws {
        // Check dimensions
        let size = roomModel.bounds.size
        if size.x <= 0 || size.y <= 0 || size.z <= 0 {
            throw RoomPlanParsingError.invalidDimensions
        }
        
        // Check for extremely small or large rooms
        let area = size.x * size.y
        if area < 1.0 { // Less than 1 square meter
            throw RoomPlanParsingError.insufficientRoomData
        }
        if area > 1000.0 { // More than 1000 square meters
            throw RoomPlanParsingError.invalidDimensions
        }
        
        // Check for placement surfaces
        let placementSurfaces = roomModel.furniture.flatMap(\.surfaces)
        if placementSurfaces.isEmpty {
            throw RoomPlanParsingError.noViableSurfaces
        }
    }
    
    /// Generate warnings based on room model analysis
    /// - Parameter roomModel: The room model to analyze
    /// - Returns: Array of warnings found
    public static func generateWarnings(for roomModel: RoomModel) -> [RoomPlanWarning] {
        var warnings: [RoomPlanWarning] = []
        
        // Check furniture detection
        if roomModel.furniture.isEmpty {
            warnings.append(.missingFurniture)
        } else {
            let lowConfidenceItems = roomModel.furniture.filter { $0.confidence < 0.5 }
            if !lowConfidenceItems.isEmpty {
                let itemNames = lowConfidenceItems.map { $0.type.rawValue }
                warnings.append(.lowConfidenceFurniture(itemNames))
            }
        }
        
        // Check wall detection
        if roomModel.walls.isEmpty {
            warnings.append(.incompleteWallDetection)
        }
        
        // Check for potential obstacle issues
        var obstacleIssues: [String] = []
        
        // Check for very thick walls that might cause RF issues
        let thickWalls = roomModel.walls.filter { $0.thickness > 0.3 }
        if !thickWalls.isEmpty {
            obstacleIssues.append("thick walls detected")
        }
        
        // Check for metal furniture that might cause RF interference
        let metalCabinets = roomModel.furniture.filter { 
            $0.type == .cabinet && $0.bounds.size.z > 1.5 
        }
        if !metalCabinets.isEmpty {
            obstacleIssues.append("large metal cabinets may cause interference")
        }
        
        if !obstacleIssues.isEmpty {
            warnings.append(.potentialObstacleIssues(obstacleIssues))
        }
        
        return warnings
    }
}

/// Extension to make RoomPlanParsingError compatible with Result type
extension RoomPlanParsingError: Error {}

/// Helper extension for error reporting
extension RoomPlanParsingError {
    
    /// Create a user-friendly error message
    public var userFriendlyMessage: String {
        switch self {
        case .invalidUSDZFile:
            return "The room scan file appears to be damaged. Please try scanning the room again."
        case .missingGeometryData:
            return "The room scan is incomplete. Please scan the room again, making sure to capture all areas."
        case .insufficientRoomData:
            return "The room scan doesn't contain enough information. Please rescan with more thorough coverage."
        case .noViableSurfaces:
            return "No suitable surfaces found for WiFi equipment placement. Ensure the room has furniture like tables or shelves."
        case .fileAccessDenied:
            return "Cannot access the scan file. Please check that the file exists and the app has permission to read it."
        case .memoryLimitExceeded:
            return "The scan is too large to process. Please try scanning a smaller area or restart the app."
        case .processingTimeout:
            return "The scan is taking too long to process. Please try a simpler scan or break large rooms into sections."
        default:
            return "An error occurred while processing the room scan. Please try again or contact support."
        }
    }
    
    /// Whether this error should be reported to analytics/crash reporting
    public var shouldReport: Bool {
        switch self {
        case .coordinateSystemMismatch, .corruptedMeshData, .memoryLimitExceeded, .processingTimeout:
            return true // These indicate system issues
        case .invalidUSDZFile, .missingGeometryData, .insufficientRoomData, .noViableSurfaces:
            return false // These are user/data issues
        case .unsupportedFileFormat, .fileAccessDenied, .invalidDimensions:
            return false // These are configuration issues
                }
    }
}
#endif
